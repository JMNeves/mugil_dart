########################
###                  ###
###       DartR      ###
### By Jessika Neves ###
###     March 2021   ###
###                  ###
########################
#
#This script was developed under the dartR version 1.1.6 available at https://cran.r-project.org/src/contrib/Archive/dartR/
#
#Load the package
library(dartR)
#
###Open the dart file###
#
setwd(choose.dir())
#
###The following command opens the csv file and converts it to gl###
dart<- gl.read.dart(filename = "mugil_dart_singlerow.csv", ind.metafile = "metrics_6sp.csv")
##Individual (=specimen or sample) metadata are user specified, and do not come from DArT.
##These metrics are supplied by the user by way of a metafile, provided at the time of inputting the SNP data
##to the genlight object. A metafile is a comma-delimited file, usually named ind_metrics.csv or similar, that
##contains labelled columns. The file must have a column headed id, which contains the individual (=specimen
##or sample labels) and a column headed pop, which contains the populations to which individuals are assigned.
#
#Procducing a heat map with the raw data
dart2<-dart[,order(dart@other$loc.metrics$CallRate, decreasing=TRUE)] #This command order the snps by callrate
gl.plot(dart2, col=c("DeepSkyBlue", "DeepPink1", "Gold"), legend = F)
#
#Plot callrate by snp
gl.report.callrate(dart, plot=T)
gl.report.callrate(dart, method = "ind", plot = TRUE, v = 2)
#
####################################################
##########                                ##########
##########       USEFUL COMMANDS          ##########
##########                                ##########
####################################################
#
nInd(dart)#| returns the number of individuals in the genlight object.
nLoc(dart)#returns the number of loci.
nPop(dart)#returns the number of populations to which the individuals are assigned.
indNames(dart)#returns or sets labels for individuals.
locNames(dart)#returns or sets labels for loci.
alleles(dart)#returns or sets allelic states of each locus for each individual (e.g. ?A/T?).
ploidy(dart)#returns or sets the ploidy of the individuals (normally diploid or 2).
pop(dart)#returns or sets the population to which each individual belongs. Try also levels(pop(gl)) for a list of unique population names.
dart@other$loc.metrics$AvgPIC #The average of the polymorphism information content (PIC) of the Reference and SNP allele rows
dart@other$loc.metrics$PICSnp #The polymorphism information content (PIC) for the SNP allele row
dart@other$loc.metrics$RepAvg # The proportion of technical replicate assay pairs for which the marker score is consistent.
NA.posi(dart)#returns the loci with missing values, that is, loci for which a sequence tag failed to amplify for each individual.
chr(dart)#returns or sets the chromosome for each locus.
position(dart)#returns or sets the position of each SNP in the sequence tag of each locus.
other(dart)#returns of sets miscellaneous information stored as a list.
glSum(dart)#counts the frequency of the alternate allele for each locus.
glNA(dart)#counts the number of missing values for each locus.
glMean(dart)#computes the relative frequency (a proportion in the range 0-1) of the second allele for each locus.
glVar(dart)#computes the variance of the allele frequency distribution for each locus.
gl.report.repavg(dart)#reports reproducibility. SNP datasets generated by DArT have in index, RepAvg, generated by reproducing the data
gl.report.heterozygosity(dart)#Calculates the observed heterozygisities by population from a genlight object and plots as a barchart ordered on heterozygosity.
#independently for 30 RepAvg is the proportion of alleles that give a reproducible result, averaged over both alleles for each locus.
gl.report.pa.pop(dart) #private alleles in each population
#The base frequencies and transition and transversion ratios can in any case be obtained using
gl.report.bases(dart)
#
#You can check the names of all available loc.metrics via:
names(dart@other$loc.metrics)
##
####################################################
##########                                ##########
##########     SUBSETTING THE DATA        ##########
##########                                ##########
####################################################
##
#table on individuals per population
table(pop(dart))
#It is easy to create a barplot on the number of individuals per population:
barplot(table(pop(dart)), las=2)
###
####Creating one dataset per popualtion####
#the command mono.rm is very important, as it keeps the invariant (fixed) snps in the array
#Mugil liza
liza <- gl.keep.pop(dart, mono.rm = FALSE, pop.list=c("liza_SA"))
#checking the data
liza
#Plotting the callrate per snp per individual
gl.report.callrate(liza)
#Mugil curema
curema <- gl.keep.pop(dart, mono.rm = FALSE, pop.list=c("cure_SA"))
curema
gl.report.callrate(curema)
#Mugil rubrioculus
rubri <- gl.keep.pop(dart, mono.rm = FALSE, pop.list=c("rubr_SA"))
rubri
gl.report.callrate(rubri)
#Mugil brevirostris
brevi <- gl.keep.pop(dart, mono.rm = FALSE, pop.list=c("brev_SA"))
brevi
gl.report.callrate(brevi)
#Mugil curvidens from SA
curv_SA <- gl.keep.pop(dart, mono.rm = FALSE, pop.list=c("curv_SA"))
curv_SA
gl.report.callrate(curv_SA)
#Mugil curvidens from MB
curv_MB <- gl.keep.pop(dart, mono.rm = FALSE, pop.list=c("curv_MB"))
curv_MB
gl.report.callrate(curv_MB)
#Putting together the two populations of Mugil curvidens
curv_all <- gl.keep.pop(dart, mono.rm = FALSE, pop.list=c("curv_MB","curv_SA"))
curv_all
gl.report.callrate(curv_all)
#Putting together Mugil curema and M. incilis
cure_inci <- gl.keep.pop(dart, mono.rm = FALSE, pop.list=c("cure_SA","inci_SA"))
cure_inci
gl.report.callrate(cure_inci)
####
####################################################
##########                                ##########
##########     FILTERING THE DATA         ##########
##########                                ##########
####################################################
##
#A suggested order here is:
#
#Filter on reproducibility, threshold (here called t, do not ask why) 97% reproducible - a meassurement of quality per loci
all<-gl.filter.repavg(dart, t=0.97)
all
#Fitler by monomorphic loci - as they do not provide information for population structure and simply slow the analysis)
mono33<-gl.filter.monomorphs(all, v=5) #v=verbosity: 0, silent or fatal errors; 1, begin and end; 2, progress log ; 3, progress and results summary; 5, full report [default 2]
mono33
#Filter by paralogs
paralogos33<- gl.filter.hamming(mono33, threshold=0.2, pb=T, v=5)
paralogos33
##################
###   6sp_0MD  ###
##################
#Filter 0% missing data
MD0_33 <- gl.filter.callrate(paralogos33, method = "loc", threshold = 1.0, mono.rm = F, recalc = F, plot = F, v = 2)
MD0_33
#Filter to remove all but one of multiple snps in the same fragment
MD0_33_1SNP<-gl.filter.secondaries(MD0_33, method="best") #filters out loci after ordering the genlight object on based on repeatability, avgPIC in that order (method="best") or at random (method="random")
MD0_33_1SNP
##################
###  6sp_20MD  ###
##################
#Filter 20% missing data
MD20_33 <-gl.filter.callrate(paralogos33, method = "loc", threshold = 0.8, mono.rm = F, recalc = F, plot = F, v = 2)
MD20_33
#Filter to remove all but one of multiple snps in the same fragment
MD20_33_1SNP<-gl.filter.secondaries(MD20_33, method="best") #filters out loci after ordering the genlight object on based on repeatability, avgPIC in that order (method="best") or at random (method="random")
MD20_33_1SNP
##################
###  6sp_40MD  ###
##################
#Filter 40% missing data
MD40_33 <-gl.filter.callrate(paralogos33, method = "loc", threshold = 0.6, mono.rm = F, recalc = F, plot = F, v = 2)
MD40_33
#Filter to remove all but one of multiple snps in the same fragment
MD40_33_1SNP<-gl.filter.secondaries(MD40_33, method="best") #filters out loci after ordering the genlight object on based on repeatability, avgPIC in that order (method="best") or at random (method="random")
MD40_33_1SNP
#
#
#####################
##    5sp_0MD      ##
## without M. liza ##
#####################
n33_semliza <- gl.keep.pop(dart, mono.rm = FALSE, pop.list=c("brev_SA","cure_SA", "inci_SA", "rubr_SA", "curv_SA", "curv_MB"))
n33_semliza
#Filter on reproducibility, threshold (here called t, do not ask why) 97% reproducible - a meassurement of quality per loci
semliza33_rep<-gl.filter.repavg(n33_semliza, t=0.97)
semliza33_rep
#Fitler by monomorphic loci - as they do not provide information for population structure and simply slow the analysis)
semliza33_mono<-gl.filter.monomorphs(semliza33_rep, v=5) #v=verbosity: 0, silent or fatal errors; 1, begin and end; 2, progress log ; 3, progress and results summary; 5, full report [default 2]
semliza33_mono
#Paralogos
semliza33_trim<- gl.filter.hamming(semliza33_mono, threshold=0.2, pb=T, v=5)
semliza33_trim
##################
#Filter 0% missing data
MD0_semliza <- gl.filter.callrate(semliza33_trim, method = "loc", threshold = 1.0, mono.rm = F, recalc = F, plot = F, v = 2)
MD0_semliza
#Filter to remove all but one of multiple snps in the same fragment
MD0_semliza_1SNP<-gl.filter.secondaries(MD0_semliza, method="best") #filters out loci after ordering the genlight object on based on repeatability, avgPIC in that order (method="best") or at random (method="random")
MD0_semliza_1SNP
#
########################
##OBS: It is also possible to filter individuals by amount of missing data just replace method="ind"
########################
#
####################################################
##########                                ##########
##########           ANALYSES             ##########
##########                                ##########
####################################################
#
##########################
#         6sp_0MD        #
# heatmap, FST, TreeMix, #
# allele richness (Ar),  #
# PCoA, STRUCTURE, RAxML #
##########################
MD0_33_1SNP
############
# Heatmap  #
############
heat0MD<-MD0_33_1SNP[,order(MD0_33_1SNP@other$loc.metrics$CallRate, decreasing=TRUE)] #ordenar snps por callrate
gl.plot(heat0MD, col=c("DeepSkyBlue", "DeepPink1", "Gold"), legend = F)
############
#    Fst   #
############
library(StAMPP)
stamppFst(MD0_33_1SNP, nboots=1, percent=95, nclusters=1)
#show Fst and p-value. The next command round Fst to 3 decimal places
fst_MD0_33 <-stamppFst(MD0_33_1SNP, nboots=1, percent=95, nclusters=1)
round(fst_MD0_33,3)
############
# Treemix  #
############
#1. blend populations
## Datasetet with M. curema and M. incilis together as the two pops of M. curvidens ##
pop(MD0_33_1SNP)
curema193<-gl.merge.pop(MD0_33_1SNP, old=c("cure_SA","inci_SA"), new="curema")
curvidens193<-gl.merge.pop(curema193, old=c("curv_MB","curv_SA"), new="curvidens")
gl.make.recode.pop(curvidens193, outfile = "new_pop_assignments33_.csv")
dart_5pop193 <- gl.recode.pop(curvidens193, pop.recode="new_pop_assignments33_.csv")
nPop(dart_5pop193)
pop(dart_5pop193)
#2. convert
gl2treemix(dart_5pop193, outfile = "treemix_input193.gz", outpath = "~/treemix",v = 2)
########################
# Allele richness (Ar) #
########################
library(adegenet)
alrc<-gl2gi(dart_5pop193)
library(PopGenReport)
allel.rich(alrc, min.alleles = NULL)
#################################################################
#Rename individuals according to morphology to the next analyses
#################################################################
MD0_6sp_33<- gl.edit.recode.ind(MD0_33_1SNP)
pop(MD0_6sp_33)
indNames(MD0_6sp_33)
#Correct the populations of renamed individuals
MD0_6sp <-gl.define.pop(MD0_6sp_33, ind.list=c("M_rubr_SA_074","M_rubr_SA_075","M_rubr_SA_077","M_rubr_SA_084"), new="rubr_SA")
pop(MD0_6sp)
MD0_6sp_ok <-gl.define.pop(MD0_6sp, ind.list=c("M_cure_MB_203"), new="cure_SA")
pop(MD0_6sp_ok)
############
#   PCoA   #
############
#run the script "PCoA_color_JessikaNeves.R" before this step
pc_0MD33 <- gl.pcoa(MD0_6sp_ok, nfactors=5)
#Plot 1x2
gl.pcoa.plot(pc_0MD33,MD0_6sp_ok, ellipse = FALSE, p = 0.95,labels = "none", hadjust = 1.5, vadjust = 1, xaxis = 1,yaxis = 2)+
  theme_bw()+coord_fixed(ratio = 1)
#Plot 3x4
gl.pcoa.plot(pc_0MD33,MD0_6sp_ok, ellipse = FALSE, p = 0.95,labels = "none", hadjust = 1.5, vadjust = 1, xaxis = 3,yaxis = 4)+
  theme_bw()+coord_fixed(ratio = 1)
############
#structure #
############
gl2structure(MD0_6sp_ok, outfile = "0MD33_struc.str",  exportMarkerNames = F)
############
#  RAxML   #
############
library(stringr)
gl2fasta(MD0_6sp_ok, method=4, outfile="phylo_0MD33_random_snp.fasta")
#Method 1 - heterozygous positions are replaced by the standard ambiguity codes. The resultant sequence fragments are
#concatenated across loci to generate a single combined sequence to be used in subsequent ML phylogenetic analyses.
#Method=2 - the heterozyous state is resolved by randomly assigning one or the other SNP variant to the individual.
#The resultant sequence fragments are concatenated across loci to generate a single composite haplotype to be used in
#subsequent ML phylogenetic analyses.
#Method 3 - heterozygous positions are replaced by the standard ambiguity codes. The resultant SNP bases are concatenated
#across loci to generate a single combined sequence to be used in subsequent MP phylogenetic analyses.
#Method=4 - the heterozyous state is resolved by randomly assigning one or the other SNP variant to the individual.
#The resultant SNP bases are concatenated across loci to generate a single composite haplotype to be used in subsequent MP phylogenetic analyses.
#
##########################
#        6sp_20MD        #
#  heatmap, PCoA, RAxML  #
##########################
MD20_33_1SNP
############
# Heatmap  #
############
heat20MD<-MD20_33_1SNP[,order(MD20_33_1SNP@other$loc.metrics$CallRate, decreasing=TRUE)] #ordenar snps por callrate
gl.plot(heat20MD, col=c("DeepSkyBlue", "DeepPink1", "Gold"), legend = F)
#################################################################
#Rename individuals according to morphology to the next analyses
#################################################################
MD20_6sp_33<- gl.edit.recode.ind(MD20_33_1SNP)
pop(MD20_6sp_33)
indNames(MD20_6sp_33)
#Correct the populations of renamed individuals
MD20_6sp <-gl.define.pop(MD20_6sp_33, ind.list=c("M_rubr_SA_074","M_rubr_SA_075","M_rubr_SA_077","M_rubr_SA_084"), new="rubr_SA")
pop(MD20_6sp)
MD20_6sp_ok <-gl.define.pop(MD20_6sp, ind.list=c("M_cure_MB_203"), new="cure_SA")
pop(MD20_6sp_ok)
############
#   PCoA   #
############
#run the script "PCoA_color_JessikaNeves.R" before this step
pc_20MD33 <- gl.pcoa(MD20_6sp_ok, nfactors=5)
#Plot 1x2
library(ggplot2)
gl.pcoa.plot(pc_20MD33,MD20_6sp_ok, ellipse = FALSE, p = 0.95,labels = "none", hadjust = 1.5, vadjust = 1, xaxis = 1,yaxis = 2)+
  theme_bw()+coord_fixed(ratio = 1)
#Plot 3x4
gl.pcoa.plot(pc_20MD33,MD20_6sp_ok, ellipse = FALSE, p = 0.95,labels = "none", hadjust = 1.5, vadjust = 1, xaxis = 3,yaxis = 4)+
  theme_bw()+coord_fixed(ratio = 1)
############
#  RAxML   #
############
library(stringr)
gl2fasta(MD20_6sp_ok, method=4, outfile="phylo_20MD33_random_snp.fasta")
#
##########################
#        6sp_40MD        #
#  heatmap, PCoA, RAxML  #
##########################
MD40_33_1SNP
############
# Heatmap  #
############
heat40MD<-MD40_33_1SNP[,order(MD40_33_1SNP@other$loc.metrics$CallRate, decreasing=TRUE)] #ordenar snps por callrate
gl.plot(heat40MD, col=c("DeepSkyBlue", "DeepPink1", "Gold"), legend = F)
#################################################################
#Rename individuals according to morphology to the next analyses
#################################################################
MD40_6sp_33<- gl.edit.recode.ind(MD40_33_1SNP)
pop(MD40_6sp_33)
indNames(MD40_6sp_33)
#Correct the populations of renamed individuals
MD40_6sp <-gl.define.pop(MD40_6sp_33, ind.list=c("M_rubr_SA_074","M_rubr_SA_075","M_rubr_SA_077","M_rubr_SA_084"), new="rubr_SA")
pop(MD40_6sp)
MD40_6sp_ok <-gl.define.pop(MD40_6sp, ind.list=c("M_cure_MB_203"), new="cure_SA")
pop(MD40_6sp_ok)
############
#   PCoA   #
############
#run the script "PCoA_color_JessikaNeves.R" before this step
pc_40MD33 <- gl.pcoa(MD40_6sp_ok, nfactors=5)
#Plot 1x2
gl.pcoa.plot(pc_40MD33,MD40_6sp_ok, ellipse = FALSE, p = 0.95,labels = "none", hadjust = 1.5, vadjust = 1, xaxis = 1,yaxis = 2)+
  theme_bw()+coord_fixed(ratio = 1)
#Plot 3x4
gl.pcoa.plot(pc_40MD33,MD40_6sp_ok, ellipse = FALSE, p = 0.95,labels = "none", hadjust = 1.5, vadjust = 1, xaxis = 3,yaxis = 4)+
  theme_bw()+coord_fixed(ratio = 1)
############
#  RAxML   #
############
library(stringr)
gl2fasta(MD40_6sp_ok, method=4, outfile="phylo_40MD33_random_snp.fasta")
#
##############################
#  5sp_0MD (without M.liza)  #
#          STRUCTURE         #
##############################
MD0_semliza_1SNP
#################################################################
#Rename individuals according to morphology to the next analyses
#################################################################
MD0_5sp_33<- gl.edit.recode.ind(MD0_semliza_1SNP)
pop(MD0_5sp_33)
indNames(MD0_5sp_33)
#Correct the populations of renamed individuals
MD0_5sp <-gl.define.pop(MD0_5sp_33, ind.list=c("M_rubr_SA_074","M_rubr_SA_075","M_rubr_SA_077","M_rubr_SA_084"), new="rubr_SA")
pop(MD0_5sp)
MD0_5sp_ok <-gl.define.pop(MD0_5sp, ind.list=c("M_cure_MB_203"), new="cure_SA")
pop(MD0_5sp_ok)
############
#structure #
############
gl2structure(MD0_5sp_ok, outfile = "0MD33_SEMLIZA_struc.str",  exportMarkerNames = F)
#
##########################
#     curvidens_0MD      #
#       STRUCTURE        #
##########################
curv33_0MD_1SNP
#################################################################
#Rename individuals according to morphology to the next analyses
#################################################################
curv_33<- gl.edit.recode.ind(curv33_0MD_1SNP)
pop(curv_33)
indNames(curv_33)
#Correct the populations of renamed individuals
curv_33_ok <-gl.define.pop(curv_33, ind.list=c("M_cure_MB_203"), new="cure_SA")
pop(curv_33_ok)
############
#structure #
############
gl2structure(curv_33_ok, outfile = "curvidens33_0MD33_struc.str",  exportMarkerNames = F)
#
##########################
#    Summary statisics   #
#      Ho, Hs, Fis       #
##########################
#Use the alignment MD0_33_1SNP to separate by species, recalculating metrics.
###
library(hierfstat)
#brevirostris
brev_stat <- gl.keep.pop(MD0_33_1SNP,recalc=TRUE,mono.rm = FALSE, pop.list=c("brev_SA"))
brev_stat
brev_gi<-gl2gi(brev_stat) #Converts a genlight object to genind object
basic.stats(brev_gi,diploid=TRUE,digits=4) #calculates basic statistics
boot.ppfis(dat=brev_gi,nboot=100) #calculates Fis confidence intervals
###
#curema
cure_stat <- gl.keep.pop(MD0_33_1SNP,recalc=TRUE, mono.rm = FALSE, pop.list=c("cure_SA","inci_SA"))
cure_stat2<-gl.define.pop(cure_stat, ind.list=c("M_inci_SA_045","M_inci_SA_182"), new="cure_SA") #reassingment of the individuals
cure_stat2
cure_gi<-gl2gi(cure_stat2) #Converts a genlight object to genind object
basic.stats(cure_gi,diploid=TRUE,digits=4) #calculates basic statistics
boot.ppfis(dat=cure_gi,nboot=100) #calculates Fis confidence intervals
###
#curvidens
curv_stat <- gl.keep.pop(MD0_33_1SNP,recalc=TRUE, mono.rm = FALSE, pop.list=c("curv_SA","curv_MB"))
curv_stat2<-gl.define.pop(curv_stat, ind.list=c("M_curv_MB_163","M_curv_MB_165",
"M_curv_MB_187","M_curv_MB_189","M_curv_MB_190","M_curv_MB_192","M_curv_MB_193",
"M_curv_MB_194","M_curv_MB_195","M_curv_MB_197","M_curv_MB_198","M_curv_MB_199",
"M_curv_MB_201","M_curv_MB_204","M_curv_MB_203"), new="curv_SA") #reassingment of the individuals
curv_stat2
curv_gi<-gl2gi(curv_stat2) #Converts a genlight object to genind object
basic.stats(curv_gi,diploid=TRUE,digits=4) #calculates basic statistics
boot.ppfis(dat=curv_gi,nboot=100) #calculates Fis confidence intervals
###
#liza
liza_stat <- gl.keep.pop(MD0_33_1SNP,recalc=TRUE, mono.rm = FALSE, pop.list=c("liza_SA"))
liza_stat
liza_gi<-gl2gi(liza_stat) #Converts a genlight object to genind object
basic.stats(liza_gi,diploid=TRUE,digits=4) #calculates basic statistics
boot.ppfis(dat=liza_gi,nboot=100) #calculates Fis confidence intervals
###
#rubrioculus
rubr_stat <- gl.keep.pop(MD0_33_1SNP,recalc=TRUE, mono.rm = FALSE, pop.list=c("rubr_SA"))
rubr_stat
rubr_gi<-gl2gi(rubr_stat) #Converts a genlight object to genind object
basic.stats(rubr_gi,diploid=TRUE,digits=4) #calculates basic statistics
boot.ppfis(dat=rubr_gi,nboot=100) #calculates Fis confidence intervals
##########################
#          DNAsp         #
#  θ, π and Tajima's D   #
##########################
#
library(stringr)
gl2fasta(MD0_33_1SNP, method=1, outfile="phylo_0MD33_DNAsp.fasta")
#Method 1 - heterozygous positions are replaced by the standard ambiguity codes. The resultant sequence fragments are
#concatenated across loci to generate a single combined sequence to be used in subsequent ML phylogenetic analyses.
#Open this file at DNAsp as "Unfold a FASTA file" and the run the analyses
#
####################################################
##########                                ##########
##########     ADDITIONAL ANALYSES        ##########
##########                                ##########
####################################################
##
################   Distance Phylogeny on resultant OTUs   ################
##
#The script for distance phylogeny is gl2phylip() which calculates Euclidean distances using dist {stats} then#
#outputs the data in a form suitable for input to the Phylip package written by Joseph Felsenstein
#(http://evolution.genetics.washington.edu/phylip.html) (Felsenstein, 1989). The input file can include replicated
#distance matrices for the purpose of bootstrapping.
phy <- gl2phylip(all_60_40_hwe_trim, outfile="dist_all_60_40_hwe_trim.phy", bstrap=1000)
##
################   SNPRelate   ################
##
#R package SNPRelate is available to undertake principal components analysis and relatedness analysis (Zheng et al., 2012).
gl2gds(MD0_33_1SNP, outfile="snprelated.gds")
##
################   AMOVA   ################
##
gl.amova(MD0_33_1SNP, nperm = 100)
##
################   SANPP   ################
##
gl2snapp(MD0_33_1SNP, outfile = "all_0MD_snapp.nex", outpath = tempdir(), v = 2)
##
##
#######################################################################################################
#
#jessika.neves@icbs.ufal.br

